# TIL Template

## 날짜: 2025-04-07

### 스크럼
- 학습 목표 1 : 기술 면접 학습

### 새로 배운 내용

<aside>

📍 **프록시 서버의 기능에 대해 설명해 주세요.**

프록시 서버 (Proxy)  
클라이언트와 서버 사이에 중계자로서 위치하는 서버

기능  
- 캐싱
  - 자주 요청되는 웹 페이지나 데이터를 저장해두고, 동일한 요청이 오면 **프록시 서버에서 직접 응답**하여 빠른 속도를 제공
- 로드 밸런싱
  - Nginx
- 컨텐츠 필터링
- 접근 제어 및 보안
  - HTTPS 프록시 →  SSL/TLS를 사용하여 통신 내용을 암호화
- 사용자 신원 은닉
  - 클라이언트의 IP주소 숨기고, 프록시 서버의 IP로 요청을 전달

</aside>

<aside>

<br>

📍 **포워드 프록시 vs 리버스 프록시**

포워드 프록시 (Forward Proxy)  
클라이언트가 웹 서버에 직접 접근하지 않고, 프록시 서버를 통해 간접적으로 데이터를 주고 받는 것

- 방화벽, 콘텐츠 필터링, 캐싱 등을 위해 사용
- 웹 브라우저나 앱에서 프록시 서버의 주소와 포트 설정



리버스 프록시 (Reverse Proxy)  
웹 서버가 클라이언트에 직접 응답하지 않고, 프록시 서버를 통해 간접적으로 데이터를 전달하는 것

- 보안, 캐싱, 로드 밸런싱 등을 위해 사용

</aside>

<aside>

<br>

📍 **VPN 과 프록시 서버의 차이점**  
VPN과 프록시 서버는 **모두 사용자의 IP를 숨기고**, 인터넷 사용 시 **중간 서버를 거친다는 점**에서 비슷해 보이지만, 실제로는 **기능과 보안 수준에서** 차이점이 있다

---

**✅ VPN vs Proxy Server 비교**

| 항목 | **VPN (Virtual Private Network)** | **Proxy Server** |
| --- | --- | --- |
| **기본 개념** | 사용자의 **전체 네트워크 트래픽을 암호화**하여 보안 터널을 통해 전송 | 웹 브라우저나 특정 애플리케이션의 **트래픽만 우회** |
| **보안 수준** | **높음**: 모든 데이터가 암호화되어 도청이나 해킹에 강함 | **낮음~중간**: 대부분 암호화되지 않음 |
| **IP 주소 숨김** | O (전체 트래픽에 대해 적용) | O (웹 브라우저 등 특정 트래픽에만 적용) |
| **속도** | 보안 프로토콜 때문에 상대적으로 **느릴 수 있음** | 일반적으로 **VPN보다 빠름** (암호화 과정 없음) |
| **설정 난이도** | 클라이언트 프로그램 설치 및 설정 필요 | 브라우저나 앱에서 간단히 설정 가능 |
| **적용 범위** | 전체 장치 또는 네트워크의 트래픽 | 주로 특정 앱이나 브라우저 수준 |
| **사용 목적** | 보안 접속, 개인정보 보호, 지역 제한 우회 등 | 캐싱, 콘텐츠 필터링, 간단한 IP 우회 등 |
| **암호화 여부** | **암호화됨** | 보통 **암호화되지 않음** |
</aside>


<aside>

<br>

📍 **HTTP란 무엇인지, HTTP 프로토콜의 가장 큰 특징은 무엇인가요?**

HTTP  
웹 환경(인터넷 또는 내부망)에서 클라이언트와 서버가 하이퍼텍스트, 이미지, 비디오 등의 다양한 리소스 교환에 사용하는 통신 규약

HTTP의 특징
- 무상태성
  - 클라이언트의 상태 정보를 **서버가 저장하지 않고**, 모든 요청은 독립적으로 처리됨
- 비연결성
  - 요청-응답 후 연결을 유지하지 않음
  - 서버는 이전 요청 상태를 기억하지 않음
  - 세션이나 쿠키로 상태를 유지할 수 있다.
- 확장성
  - 새로운 **HTTP 메서드** 정의, **상태코드** 사용, 헤더에 **새로운 필드** 추가
  등으로 기능을 확장할 수 있다

- 텍스트 기반
  - 사람이 읽을 수 있는 구조와 언어로 통신
- 클라이언트-서버 구조
  - 클라이언트(보통 브라우저)가 요청하고, 서버가 응답 → 역할이 명확하게 분리
</aside>

<aside>

<br>

📍 **HTTP와 HTTPS의 차이**

HTTPS
HTTP에 **SSL/TLS 보안 계층을 추가**하여, **암호화, 인증, 무결성 보장** 등의 추가적인 기능을 제공하는 프로토콜

- 보안: **SSL/TLS** 로 데이터 암호화
- 인증 : **SSL/TLS 인증서** → 서버 신원 인증 ****
- 성능
  - 데이터 암호화/인증 과정에 추가적인 시간과 자원 소모
  - HTTP/2 나, CDN과 같은 캐싱 기술로 인해 거의 차이 없음

→ 요즘 웹의 기본

</aside>

<aside>

<br>

📍 **HTTPS 동작 방식**

1. 클라이언트가 서버에 접속 요청
2. 서버가 자신의 **공개키를 담은 인증서**를 클라이언트에게 전송
  1. 인증서 신뢰할 수 있는 기관(CA)에 의해 발급
3. 클라이언트가 인증서 검증 - CA에서 서명했는지 확인
4. 클라이언트가 **대칭키** 생성 → 서버의 **공개키**로 암호화해서 서버에 전송
5. 서버는 자신의 **비밀키**로 클라이언트가 보낸 대칭키를 복호화
6. 클라이언트와 서버는 대칭키를 공유하게 되고, 이를 활용하여 통신

→ 중간자 공격과 데이터 위변조를 방지

</aside>


<aside>

<br>

📍 **GET, POST, PUT, DELETE에 대해 설명해주세요**

GET
- 서버에게 특정 리소스를 요청하는 메서드
- 요청 데이터는 URL의 쿼리 스트링으로 전달
- 캐시 가능하고, 안전하고, 멱등(idempotent)함

POST
- 서버에게 새로운 리소스를 생성하거나 기존 리소스를 수정하라고 요청하
  는 메서드
- 요청 데이터는 HTTP 바디에 담겨 전달
- 캐시가 불가능하고, 안전하지 않고, **멱등하지 않음**

PUT
- 서버에게 특정 리소스를 전체적으로 교체하거나 생성하라고 요청하는 메
  서드
- 요청 데이터는 HTTP 바디에 담겨 전달
- 캐시가 불가능하고, 안전하지 않고, 멱등

DELETE
- 서버에게 특정 리소스를 삭제하라고 요청하는 메서드
- 요청 데이터는 URL의 쿼리 스트링으로 전달
- 캐시가 불가능하고, 안전하지 않고, 멱등

---

가장 안전한 메서드는 GET  
→ 서버의 상태를 변경하지 않는 단순한 조회 작업

멱등하지 않은 유일한 메서드 POST  
→ 멱등성이란, **동일한 연산을 여러 번 수행해도 결과가 달라지지 않는 성질**  
→ 같은 내용의 POST 요청을 여러 번 보내면 서버에 중복된 리소스가 생성

</aside>

<aside>

<br>

📍 **멱등한 API**  
POST 같은 비멱등 메서드도 요청을 재전송하더라도 중복 처리를 막고 싶을 때, **요청 헤더에 멱등키**를 포함하면 된다

```css
POST /payments
Host: api.tosspayments.com
Idempotency-Key: 84a22919-7baf-4d8c-a88a-810dd41ecf73
Content-Type: application/json

{
  "amount": 10000,
  "orderId": "order-1234"
}
```

동일한 멱등키로 다시 요청이 오면? **처리하지 않고**, 처음 응답을 그대로 반환  
→ **네트워크 오류**나 **사용자 재시도**로 같은 요청이 **중복 처리되는 걸 방지**  
→ 결제, 예약, 주문 등 **단일 처리만 허용되는 요청**에 꼭 필요

</aside>